{"version":3,"sources":["C:/Users/liliang/AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/base64-js/index.js","C:/Users/liliang/AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/ieee754/index.js","C:/Users/liliang/AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/isarray/index.js","C:/Users/liliang/AppData/Roaming/npm/node_modules/parcel-bundler/node_modules/buffer/index.js","src/index.js"],"names":["styleStr","styleEl","document","getElementById","newStyleEl","createElement","type","id","innerHTML","head","appendChild","source","icons","isIconsLoaded","base64Strs","bufIcons","blockEnd","blockFront","bomb","bombActive","flag","flagActive","rtnObj","Object","keys","forEach","_","toString","loadSingleIcon","key","Promise","resolve","image","Image","onload","src","loadIcons","all","map","then","values","item","Block","row","col","num","isFlag","isOpened","context","size","space","fontSize","color","fw","measureText","width","tx","ty","save","font","textBaseline","fillStyle","fillText","restore","icon","dw","dh","height","dx","dy","drawImage","params","drawBG","drawText","drawIcon","utils","createCanvas","wrapper","canvas","className","body","getPixRatio","backingStore","backingStorePixelRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","window","devicePixelRatio","genBlocks","rows","cols","blocks","push","Game","mineCount","blockSpace","getContext","pixRatio","initUI","addListener","blockSize","isEnd","isFirstClick","updateSize","drawBlocks","offsetWidth","canvasHeight","canvasWidth","maxHeight","innerHeight","Math","floor","clearRect","block","draw","event","ex","offsetX","pageX","ey","offsetY","pageY","curCol","curRow","i","len","length","addEventListener","onClick","bind","onContextmenu","curBlock","getCurBlock","updateMineMap","openZeroBlocks","bombAndOver","checkDone","alert","preventDefault","numArray","Array","fill","sort","random","curIndex","indexOf","index","updateBlocksNum","tl","tm","tr","r","br","bm","bl","l","arr","filter","t","b","getRoundBlocks","checkedBlocks","noCheckBlocks","pop","roundBlocks","getTRBLBlocks"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxvDA;;;;;;;;;;;;;;;;;;;;;;AAEA,CAAC,YAAW;AACV,MAAIA,QAAQ,sbAAZ;AACA,MAAMC,OAAO,GAAGC,QAAQ,CAACC,cAAT,CAAwB,gBAAxB,CAAhB;AACA,MAAIF,OAAJ,EAAa;AACb,MAAMG,UAAU,GAAGF,QAAQ,CAACG,aAAT,CAAuB,OAAvB,CAAnB;AACAD,EAAAA,UAAU,CAACE,IAAX,GAAkB,UAAlB;AACAF,EAAAA,UAAU,CAACG,EAAX,GAAgB,gBAAhB;AACAH,EAAAA,UAAU,CAACI,SAAX,GAAuBR,QAAvB;AACAE,EAAAA,QAAQ,CAACO,IAAT,CAAcC,WAAd,CAA0BN,UAA1B;AACD,CATA,EAAD;AAWA,IAAMO,MAAM,GAAG;AAAEC,EAAAA,KAAK,EAAE,EAAT;AAAaC,EAAAA,aAAa,EAAE;AAA5B,CAAf;;AAEAF,MAAM,CAACG,UAAP,GAAqB,YAAM;AACzB,MAAMC,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","file":"src.a2b27638.map","sourceRoot":"..","sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","/**\r\n * \r\n * author: liliang\r\n */\r\n\r\nimport fs from 'fs'\r\n\r\n!function() {\r\n  let styleStr = fs.readFileSync(__dirname + '/assets/css/style.css', 'utf8')\r\n  const styleEl = document.getElementById('gameStylesheet')\r\n  if (styleEl) return\r\n  const newStyleEl = document.createElement('style')\r\n  newStyleEl.type = 'text/css'\r\n  newStyleEl.id = 'gameStylesheet'\r\n  newStyleEl.innerHTML = styleStr\r\n  document.head.appendChild(newStyleEl)\r\n}()\r\n\r\nconst source = { icons: {}, isIconsLoaded: false }\r\n\r\nsource.base64Strs = (() => {\r\n  const bufIcons = {\r\n    blockEnd: fs.readFileSync(__dirname + '/assets/img/back.png'),\r\n    blockFront: fs.readFileSync(__dirname + '/assets/img/front.png'),\r\n    bomb: fs.readFileSync(__dirname + '/assets/img/bomb.png'),\r\n    bombActive: fs.readFileSync(__dirname + '/assets/img/bomb-color.png'),\r\n    flag: fs.readFileSync(__dirname + '/assets/img/flag.png'),\r\n    flagActive: fs.readFileSync(__dirname + '/assets/img/flag-color.png')\r\n  }, rtnObj = {}\r\n  Object.keys(bufIcons).forEach(_ => \r\n    rtnObj[_] = `data:image/png;base64,${bufIcons[_].toString('base64')}`\r\n  )\r\n  return rtnObj\r\n})()\r\n\r\nsource.loadSingleIcon = function (key) {\r\n  return new Promise(resolve => {\r\n    const image = new Image()\r\n    image.onload = () => {\r\n      image.onload = null\r\n      resolve({ [key]: image })\r\n    }\r\n    image.src = this.base64Strs[key]\r\n  })\r\n}\r\n\r\nsource.loadIcons = function () {\r\n  if (this.isIconsLoaded) return Promise.resolve()\r\n  return Promise.all(Object.keys(this.base64Strs).map(_ => \r\n    this.loadSingleIcon(_)\r\n  )).then(values => {\r\n    this.isIconsLoaded = true\r\n    values.forEach(item => this.icons = { ...this.icons, ...item })\r\n  })\r\n}\r\n\r\nclass Block {\r\n  constructor({ row, col, num = 0 }) {\r\n    this.row = row\r\n    this.col = col\r\n    this.num = num\r\n    this.isFlag = false\r\n    this.isOpened = false\r\n  }\r\n\r\n  drawText({ context, size, space }) {\r\n    let fontSize = size / 2 + 'px'\r\n    let color = ({ 1: '#ff0', 2: '#0f0' })[this.num] || '#f00'\r\n    let fw = context.measureText(this.num).width\r\n    let tx = this.col * size + (size - space - fw) / 2\r\n    let ty = this.row * size + (size - space - fw) / 2\r\n    context.save()\r\n    context.font = `bold ${fontSize} serif`\r\n    context.textBaseline = 'hanging'\r\n    context.fillStyle = color\r\n    context.fillText(this.num, tx, ty)\r\n    context.restore()\r\n  }\r\n\r\n  drawIcon({ context, size, space, icon }) {\r\n    let dw, dh\r\n    if (icon.width > icon.height) {\r\n      dw = size * .5\r\n      dh = dw * (icon.height / icon.width)\r\n    } else {\r\n      dh = size * .5\r\n      dw = dh * (icon.width / icon.height)\r\n    }\r\n    let dx = this.col * size + space + (size - space - dw) / 2\r\n    let dy = this.row * size + space + (size - space - dh) / 2\r\n    context.drawImage(icon, dx, dy, dw, dh)\r\n  }\r\n\r\n  drawBG({ context, size, space, icon }) {\r\n    context.drawImage(\r\n      icon, 0, 0, icon.width, icon.height,\r\n      this.col * size + space, this.row * size + space, size - space, size - space\r\n    )\r\n  }\r\n\r\n  draw({ context, size, space = 6 }) {\r\n    let params = { context, size, space }\r\n    let { blockEnd, bomb, blockFront, flagActive } = source.icons\r\n    if (this.isOpened) {\r\n      this.drawBG({ ...params, icon: blockEnd })\r\n      if (this.num > 0 && this.num < 9) {\r\n        this.drawText(params)\r\n      } else if (this.num === 9) {\r\n        this.drawIcon({ ...params, icon: bomb })\r\n      }\r\n    } else {\r\n      this.drawBG({ ...params, icon: blockFront })\r\n      if (this.isFlag) {\r\n        this.drawIcon({ ...params, icon: flagActive })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst utils = {\r\n  createCanvas() {\r\n    const wrapper = document.createElement('div')\r\n    const canvas = document.createElement('canvas')\r\n    wrapper.className = 'game-wrapper'\r\n    canvas.className = 'game-ui'\r\n    wrapper.appendChild(canvas)\r\n    document.body.appendChild(wrapper)\r\n    return canvas\r\n  },\r\n\r\n  getPixRatio(context) {\r\n    var backingStore = context.backingStorePixelRatio ||\r\n      context.webkitBackingStorePixelRatio ||\r\n      context.mozBackingStorePixelRatio || 1\r\n    return (window.devicePixelRatio || 1) / backingStore\r\n  },\r\n\r\n  genBlocks(rows, cols) {\r\n    const blocks = []\r\n    for (let row = 0; row < rows; row++) {\r\n      for (let col = 0; col < cols; col++) {\r\n        blocks.push(new Block({ row, col }))\r\n      }\r\n    }\r\n    return blocks\r\n  }\r\n}\r\n\r\nclass Game {\r\n  constructor({ rows, cols, mineCount, blockSpace }) {\r\n    this.canvas = utils.createCanvas()\r\n    this.context = this.canvas.getContext('2d')\r\n    this.pixRatio = utils.getPixRatio(this.context)\r\n    this.initUI({ rows, cols, mineCount, blockSpace })\r\n    this.addListener()\r\n  }\r\n\r\n  initUI({ rows, cols, mineCount, blockSpace = 6 }) {\r\n    this.rows = rows\r\n    this.cols = cols\r\n    this.mineCount = mineCount\r\n    this.blockSpace = blockSpace\r\n    this.blockSize = 0\r\n    this.isEnd = false\r\n    this.isFirstClick = true\r\n    this.updateSize()\r\n    this.blocks = utils.genBlocks(this.rows, this.cols)\r\n    this.drawBlocks()\r\n  }\r\n\r\n  updateSize() {\r\n    let width = this.canvas.offsetWidth\r\n    let canvasHeight, canvasWidth = this.pixRatio * width\r\n    let blockSize = (canvasWidth - this.blockSpace) / this.cols\r\n    let maxHeight = this.pixRatio * (window.innerHeight - 100)\r\n    if (this.rows) {\r\n      if (this.rows * blockSize > maxHeight) {\r\n        this.rows = Math.floor(maxHeight / blockSize)\r\n      }\r\n      canvasHeight = this.rows * blockSize + this.blockSpace\r\n    } else {\r\n      this.rows = this.cols\r\n      canvasHeight = canvasWidth\r\n    }\r\n    this.blockSize = blockSize\r\n    this.canvas.width = canvasWidth\r\n    this.canvas.height = canvasHeight\r\n  }\r\n\r\n  drawBlocks() {\r\n    let { width, height } = this.canvas\r\n    this.context.clearRect(0, 0, +width, +height)\r\n    this.blocks.forEach(block => {\r\n      block.draw({\r\n        context: this.context,\r\n        size: this.blockSize,\r\n        space: this.blockSpace\r\n      })\r\n    })\r\n  }\r\n\r\n  getCurBlock(event) {\r\n    let ex = (event.offsetX || event.pageX) * this.pixRatio\r\n    let ey = (event.offsetY || event.pageY) * this.pixRatio\r\n    let curCol = Math.floor(ex / this.blockSize)\r\n    let curRow = Math.floor(ey / this.blockSize)\r\n    for (let i = 0, len = this.blocks.length; i < len; i++) {\r\n      let _ = this.blocks[i]\r\n      if (_.row === curRow && _.col === curCol) return _\r\n    }\r\n  }\r\n\r\n  addListener() {\r\n    this.canvas.addEventListener('click', this.onClick.bind(this), false)\r\n    this.canvas.addEventListener('contextmenu', this.onContextmenu.bind(this), false)\r\n  }\r\n\r\n  onClick(event) {\r\n    if (this.isEnd) return\r\n    let curBlock = this.getCurBlock(event)\r\n    if (!curBlock || curBlock.isOpened || curBlock.isFlag) return\r\n    if (this.isFirstClick) {\r\n      this.updateMineMap(curBlock)\r\n      this.isFirstClick = false\r\n    }\r\n    curBlock.isOpened = true\r\n    this.drawBlocks()\r\n    if (!curBlock.num) {\r\n      this.openZeroBlocks(curBlock)\r\n    } else if (curBlock.num === 9) {\r\n      this.bombAndOver()\r\n    }\r\n    if (this.checkDone()) {\r\n      alert('')\r\n    }\r\n  }\r\n\r\n  onContextmenu(event) {\r\n    event.preventDefault()\r\n    if (this.isEnd) return\r\n    let curBlock = this.getCurBlock(event)\r\n    if (!curBlock || curBlock.isOpened) return\r\n    curBlock.isFlag = !curBlock.isFlag\r\n    this.drawBlocks()\r\n  }\r\n\r\n  updateMineMap(block) {\r\n    let numArray = [\r\n      ...Array(this.mineCount).fill(9), \r\n      ...Array(this.blocks.length - this.mineCount).fill(0)\r\n    ]\r\n    numArray.sort(() => Math.random() - .5)\r\n    let curIndex = this.blocks.indexOf(block)\r\n    if (numArray[curIndex] === 9) {\r\n      for (let i = 0, len = numArray.length; i < len; i++) {\r\n        if (!numArray[i]) {\r\n          numArray[curIndex] = 0\r\n          numArray[i] = 9\r\n          break\r\n        }\r\n      }\r\n    }\r\n    numArray.forEach((num, index) => this.blocks[index].num = num)\r\n    this.updateBlocksNum()\r\n  }\r\n\r\n  getRoundBlocks(i) {\r\n    let tl = this.blocks[i - this.cols - 1]\r\n    let tm = this.blocks[i - this.cols]\r\n    let tr = this.blocks[i - this.cols + 1]\r\n    let r = this.blocks[i + 1]\r\n    let br = this.blocks[i + this.cols + 1]\r\n    let bm = this.blocks[i + this.cols]\r\n    let bl = this.blocks[i + this.cols - 1]\r\n    let l = this.blocks[i - 1]\r\n    let arr = [tl, tm, tr, r, br, bm, bl, l]\r\n    if (i % this.cols === 0) {\r\n      arr = [tm, tr, r, br, bm]\r\n    } else if ((i + 1) % this.cols === 0) {\r\n      arr = [tl, tm, bm, bl, l]\r\n    }\r\n    return arr.filter(_ => _)\r\n  }\r\n\r\n  getTRBLBlocks(i) {\r\n    let t = this.blocks[i - this.cols]\r\n    let r = this.blocks[i + 1]\r\n    let b = this.blocks[i + this.cols]\r\n    let l = this.blocks[i - 1]\r\n    let arr = [t, r, b, l]\r\n    if (i % this.cols === 0) {\r\n      arr = [t, r, b]\r\n    } else if ((i + 1) % this.cols === 0) {\r\n      arr = [t, b, l]\r\n    }\r\n    return arr.filter(_ => _)\r\n  }\r\n\r\n  updateBlocksNum() {\r\n    for (let i = 0, len = this.blocks.length; i < len; i++) {\r\n      let block = this.blocks[i]\r\n      if (block.num === 9) continue\r\n      block.num = this.getRoundBlocks(i).filter(_ => _.num === 9).length\r\n    }\r\n  }\r\n\r\n  bombAndOver() {\r\n    let { context, blockSize: size, blockSpace: space } = this\r\n    this.blocks.forEach(_ => {\r\n      if (_.num === 9) {\r\n        _.isOpened = true\r\n        _.draw({ context, size, space })\r\n      }\r\n    })\r\n    this.isEnd = true\r\n  }\r\n\r\n  openZeroBlocks(block) {\r\n    let checkedBlocks = [], noCheckBlocks = [block]\r\n    while (noCheckBlocks.length) {\r\n      let b = noCheckBlocks.pop()\r\n      if (checkedBlocks.indexOf(b) === -1) checkedBlocks.push(b)\r\n      let index = this.blocks.indexOf(b)\r\n      let roundBlocks = this.getTRBLBlocks(index)\r\n      for (let i = 0, len = roundBlocks.length; i < len; i++) {\r\n        let _ = roundBlocks[i]\r\n        if (!_.num && !_.isFlag && checkedBlocks.indexOf(_) === -1) {\r\n          noCheckBlocks.push(_)\r\n        }\r\n      }\r\n    }\r\n    checkedBlocks.forEach(_ => _.isOpened = true)\r\n    this.drawBlocks()\r\n  }\r\n\r\n  checkDone() {\r\n    for (let i = 0, len = this.blocks.length; i < len; i++) {\r\n      let _ = this.blocks[i]\r\n      if (_.num !== 9 && !_.isOpened) return false\r\n    }\r\n    return true\r\n  }\r\n}\r\n\r\nsource.loadIcons().then(() => {\r\n  new Game({ cols: 9, mineCount: 10 })\r\n})"]}